#ifndef BPT_MEMORYRIVER_HPP
#define BPT_MEMORYRIVER_HPP

#include <cassert>
#include <filesystem>
#include <fstream>

// A persistent container that stores a POD object, and support storing some extra int info.
//
// Template Args:
//  T: The type of the object to be stored. Must be POD.
//  info_len: the extra info (of type int) that can be stored in MemoryRiver. Default set to 2.
template <class T, int info_len = 2>
class MemoryRiver {
    static_assert(std::is_trivially_copyable_v<T>, "T must be POD");
    static_assert(sizeof(T) >= sizeof(int), "The sizeof T must be greater than size of int");

public:
    MemoryRiver() = default;
    MemoryRiver(const std::string& _file_name) : file_name(_file_name) {}
    ~MemoryRiver();

    // Initializes MemoryRiver. This function must be called before use of other functions.
    void initialise(const std::string& _file_name = "");
    // Gets the value of the n-th info (1-based).
    void getInfo(int& tmp, int n);
    // Writes tmp into the n-th info (1-based).
    void writeInfo(int tmp, int n);

    // Writes t in to file. Returns an index for future operations.
    // The index retyrurned will always be a positive integer.
    int write(const T& t);
    // Updates the object at index with t. The index is that generated by write before.
    void update(const T& t, int index);
    // Partially updates the object at index with t. The index is that generated by write before.
    template <class U>
    void update(const U& u, int index, size_t offset);
    // Reads the object at index. The index is that generated by write before.
    void read(T& t, int index);
    // Partially reads the object at index. The index is that generated by write before.
    template <class U>
    void read(U& u, int index, size_t offset);
    // Deletes the object at index.
    void erase(int index);

private:
    int count = 0;
    int free_head = 0;
    std::fstream file;
    std::string file_name;

    static constexpr int SUPER_INFO_LEN = 2;
    static constexpr int GLOBAL_OFFSET = SUPER_INFO_LEN * sizeof(int);
    static constexpr int SIZEOF_T = sizeof(T);

    // Initializes a new file.
    void initFile();
    // Opens the existing file.
    void openFile();
    // Returns the next pointer for the free list.
    int getNext(int index);
    // Modifies the next pointer for the free list.
    void writeNext(int index, int val);
};

template <class T, int info_len>
MemoryRiver<T, info_len>::~MemoryRiver() {
    writeInfo(count, -1);
    writeInfo(free_head, 0);
    file.close();
}
template <class T, int info_len>
void MemoryRiver<T, info_len>::initialise(const std::string& _file_name) {
    if (!_file_name.empty()) file_name = _file_name;
    if (!std::filesystem::exists(file_name)) {
        initFile();
    }
    openFile();
}
template <class T, int info_len>
void MemoryRiver<T, info_len>::getInfo(int& tmp, int n) {
    if (n > info_len) return;
    assert(file.is_open());
    file.seekg(GLOBAL_OFFSET + (n - 1) * sizeof(int));
    file.read(reinterpret_cast<char*>(&tmp), sizeof(int));
}
template <class T, int info_len>
void MemoryRiver<T, info_len>::writeInfo(int tmp, int n) {
    if (n > info_len) return;
    assert(file.is_open());
    file.seekp(GLOBAL_OFFSET + (n - 1) * sizeof(int));
    file.write(reinterpret_cast<const char*>(&tmp), sizeof(int));
}
template <class T, int info_len>
int MemoryRiver<T, info_len>::write(const T& t) {
    assert(file.is_open());
    if (!free_head) {
        file.seekp(GLOBAL_OFFSET + (info_len) * sizeof(int) + SIZEOF_T * count);
        file.write(reinterpret_cast<const char*>(&t), SIZEOF_T);
        return ++count;
    }
    const int pos = free_head;
    free_head = getNext(free_head);
    file.seekp(GLOBAL_OFFSET + (info_len) * sizeof(int) + SIZEOF_T * (pos - 1));
    file.write(reinterpret_cast<const char*>(&t), SIZEOF_T);
    return pos;
}
template <class T, int info_len>
void MemoryRiver<T, info_len>::update(const T& t, const int index) {
    assert(file.is_open());
    file.seekp(GLOBAL_OFFSET + (info_len) * sizeof(int) + SIZEOF_T * (index - 1));
    file.write(reinterpret_cast<const char*>(&t), SIZEOF_T);
}
template <class T, int info_len>
template <class U>
void MemoryRiver<T, info_len>::update(const U& u, const int index, const size_t offset) {
    file.seekp(GLOBAL_OFFSET + (info_len) * sizeof(int) + SIZEOF_T * (index - 1) + offset);
    file.write(reinterpret_cast<const char*>(&u), sizeof(U));
}
template <class T, int info_len>
void MemoryRiver<T, info_len>::read(T& t, const int index) {
    assert(file.is_open());
    file.seekg(GLOBAL_OFFSET + (info_len) * sizeof(int) + SIZEOF_T * (index - 1));
    file.read(reinterpret_cast<char*>(&t), SIZEOF_T);
}
template <class T, int info_len>
template <class U>
void MemoryRiver<T, info_len>::read(U& u, const int index, const size_t offset) {
    file.seekg(GLOBAL_OFFSET + (info_len) * sizeof(int) + SIZEOF_T * (index - 1) + offset);
    file.read(reinterpret_cast<char*>(&u), sizeof(U));
}
template <class T, int info_len>
void MemoryRiver<T, info_len>::erase(const int index) {
    assert(file.is_open());
    writeNext(index, free_head);
    free_head = index;
}

template <class T, int info_len>
void MemoryRiver<T, info_len>::initFile() {
    file.open(file_name, std::ios::out | std::ios::binary);
    int tmp = 0;
    for (int i = 0; i < info_len + SUPER_INFO_LEN; ++i)
        file.write(reinterpret_cast<char*>(&tmp), sizeof(int));
    file.close();
}
template <class T, int info_len>
void MemoryRiver<T, info_len>::openFile() {
    file.open(file_name, std::ios::in | std::ios::out | std::ios::binary);
    getInfo(count, -1);
    getInfo(free_head, 0);
}
template <class T, int info_len>
int MemoryRiver<T, info_len>::getNext(int index) {
    int nxt;
    file.seekg(GLOBAL_OFFSET + (info_len) * sizeof(int) + SIZEOF_T * (index - 1));
    file.read(reinterpret_cast<char*>(&nxt), sizeof(int));
    return nxt;
}
template <class T, int info_len>
void MemoryRiver<T, info_len>::writeNext(int index, int val) {
    file.seekp(GLOBAL_OFFSET + (info_len) * sizeof(int) + SIZEOF_T * (index - 1));
    file.write(reinterpret_cast<const char*>(&val), sizeof(int));
}

#endif  // BPT_MEMORYRIVER_HPP